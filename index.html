<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Collaborative Whiteboard with Multiâ€‘Page & Delete</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
      background: #f0f2f5;
    }
    /* Navigation Bar */
    nav.navbar {
      background: linear-gradient(45deg, #4a90e2, #50c0e9);
      padding: 10px 20px;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 200;
      display: flex;
      justify-content: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    nav.navbar .nav-container {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    nav.navbar button,
    nav.navbar input[type="color"],
    nav.navbar input[type="range"] {
      background: #fff;
      border: 1px solid #ddd;
      padding: 8px 12px;
      color: #333;
      border-radius: 6px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    nav.navbar button:hover,
    nav.navbar input[type="color"]:hover,
    nav.navbar input[type="range"]:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
    /* Page Navigation Area */
    #pageNav {
      display: flex;
      gap: 5px;
      align-items: center;
      margin-left: 20px;
    }
    #pageNav > span {
      color: #fff;
      font-weight: bold;
    }
    /* This label shows current page info */
    #currentPageLabel {
      margin-left: 10px;
      font-size: 1rem;
      color: #fff;
      font-weight: bold;
    }
    /* Canvas styling */
    canvas {
      display: block;
      background: #fff;
      /* Leave space for the nav bar (set here to 70px) */
      height: calc(100vh - 70px);
      margin-top: 70px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <nav class="navbar">
    <div class="nav-container">
      <button id="draw">Free Draw</button>
      <button id="line">Line</button>
      <button id="rect">Rectangle</button>
      <button id="circle">Circle</button>
      <button id="dotted">Dotted Line</button>
      <button id="dashed">Dashed Line</button>
      <button id="eraser">Eraser</button>
      <button id="fill">Fill Bucket</button>
      <button id="undo">Undo</button>
      <button id="redo">Redo</button>
      <button id="clear">Clear Screen</button>
      <input type="color" id="colorPicker" value="#000000" />
      <!-- Marker size range now from 1 to 100 -->
      <input type="range" id="sizePicker" min="1" max="100" value="3" />
      
      <!-- Page Navigation Section -->
      <div id="pageNav">
        <span>Pages:</span>
        <button id="newPage">New Page</button>
        <button id="deletePage">Delete Page</button>
        <span id="pagesContainer"></span>
        <span id="currentPageLabel"></span>
      </div>
    </div>
  </nav>
  <canvas id="whiteboard"></canvas>
  
  <script>
    // Get canvas and context
    const canvas = document.getElementById("whiteboard");
    const ctx = canvas.getContext("2d");
    // Adjust canvas size (subtracting 70px for the nav bar)
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 70;

    // ---------- Global Drawing Variables ------------
    let tool = "draw"; // "draw", "line", "rect", "circle", "dotted", "dashed", "eraser", "fill"
    let isDrawing = false;
    let startX = 0, startY = 0;
    let savedImageData = null; // For shape preview
    let color = "#000";
    let size = 3;
    
    // ---------- Multi-Page Variables ------------
    let pages = [];           // Array to store each page's object { data, undoStack, redoStack }
    let currentPageIndex = 0; // Index for the current page
    let undoStack = [];       // Undo stack for the current page
    let redoStack = [];       // Redo stack for the current page

    // ---------- Flood Fill Helpers ------------
    function getPixelColor(x, y, data) {
      const index = (y * canvas.width + x) * 4;
      return [data[index], data[index+1], data[index+2], data[index+3]];
    }

    function matchColor(a, b) {
      return (
        Math.abs(a[0] - b[0]) < 10 &&
        Math.abs(a[1] - b[1]) < 10 &&
        Math.abs(a[2] - b[2]) < 10 &&
        Math.abs(a[3] - b[3]) < 10
      );
    }
    
    function floodFill(x, y, fillColor) {
      x = Math.floor(x);
      y = Math.floor(y);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const targetColor = getPixelColor(x, y, data);
      const fillR = parseInt(fillColor.slice(1, 3), 16);
      const fillG = parseInt(fillColor.slice(3, 5), 16);
      const fillB = parseInt(fillColor.slice(5, 7), 16);
      const fillA = 255;
      
      if (matchColor(targetColor, [fillR, fillG, fillB, fillA])) return;
      
      const stack = [[x, y]];
      while (stack.length) {
        const [cx, cy] = stack.pop();
        const index = (cy * canvas.width + cx) * 4;
        const currentColor = [
          data[index],
          data[index+1],
          data[index+2],
          data[index+3]
        ];
        if (matchColor(currentColor, targetColor)) {
          data[index] = fillR;
          data[index+1] = fillG;
          data[index+2] = fillB;
          data[index+3] = fillA;
          if (cx + 1 < canvas.width) stack.push([cx + 1, cy]);
          if (cx - 1 >= 0) stack.push([cx - 1, cy]);
          if (cy + 1 < canvas.height) stack.push([cx, cy + 1]);
          if (cy - 1 >= 0) stack.push([cx, cy - 1]);
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    // ---------- Undo/Redo Functions ------------
    function saveState() {
      undoStack.push(canvas.toDataURL());
      redoStack = [];
      savePageState(); // update current page object with new state
    }
    
    function undo() {
      if (undoStack.length) {
        const lastState = undoStack.pop();
        redoStack.push(canvas.toDataURL());
        loadState(lastState);
        savePageState();
      }
    }
    
    function redo() {
      if (redoStack.length) {
        const nextState = redoStack.pop();
        undoStack.push(canvas.toDataURL());
        loadState(nextState);
        savePageState();
      }
    }
    
    function loadState(state) {
      const img = new Image();
      img.src = state;
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };
    }
    
    // ---------- Shape Preview and Final Drawing ------------
    function drawShape(e, preview) {
      ctx.lineWidth = size;
      ctx.lineCap = "round";
      ctx.strokeStyle = preview ? "rgba(0,0,0,0.5)" : color;
      
      if (tool === "dotted") {
        ctx.setLineDash([2, 6]);
      } else if (tool === "dashed") {
        ctx.setLineDash([10, 10]);
      } else {
        ctx.setLineDash([]);
      }
      
      // Adjust the Y coordinate for the nav bar height (70px)
      if (tool === "line" || tool === "dotted" || tool === "dashed") {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(e.clientX, e.clientY - 70);
        ctx.stroke();
      } else if (tool === "rect") {
        const w = e.clientX - startX;
        const h = (e.clientY - 70) - startY;
        ctx.strokeRect(startX, startY, w, h);
      } else if (tool === "circle") {
        const radius = Math.sqrt(
          Math.pow(e.clientX - startX, 2) + Math.pow((e.clientY - 70) - startY, 2)
        );
        ctx.beginPath();
        ctx.arc(startX, startY, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }
    
    // ---------- Multi-Page Functions ------------
    function savePageState() {
      // Save current canvas state and undo/redo stacks in the current page object
      if (currentPageIndex < pages.length) {
        pages[currentPageIndex].data = canvas.toDataURL();
        pages[currentPageIndex].undoStack = undoStack.slice();
        pages[currentPageIndex].redoStack = redoStack.slice();
      }
    }
    
    function createNewPage() {
      // Clear canvas for a new page and add a new object to pages
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let newPageObj = { data: canvas.toDataURL(), undoStack: [], redoStack: [] };
      pages.push(newPageObj);
      currentPageIndex = pages.length - 1;
      // Reset local undo/redo stacks for the new page
      undoStack = [];
      redoStack = [];
      updatePageNavButtons();
      saveState();
    }
    
    function switchToPage(index) {
      savePageState();
      currentPageIndex = index;
      let pageObj = pages[currentPageIndex];
      loadState(pageObj.data);
      // Set the undo/redo stacks to the selected page's stacks
      undoStack = pageObj.undoStack.slice();
      redoStack = pageObj.redoStack.slice();
      updatePageNavButtons();
    }
    
    function updatePageNavButtons() {
      const pagesContainer = document.getElementById("pagesContainer");
      pagesContainer.innerHTML = "";
      for (let i = 0; i < pages.length; i++) {
        const btn = document.createElement("button");
        btn.textContent = i + 1; // Display page numbers as 1-indexed
        if (i === currentPageIndex) {
          btn.style.backgroundColor = "#fff";
          btn.style.color = "#333";
        }
        btn.addEventListener("click", () => switchToPage(i));
        pagesContainer.appendChild(btn);
      }
      // Update current page label
      document.getElementById("currentPageLabel").textContent = "Current Page: " + (currentPageIndex + 1);
    }
    
    function deleteCurrentPage() {
      // Allow deletion only if there is more than one page
      if (pages.length === 1) {
        alert("Cannot delete the only page.");
        return;
      }
      // Remove current page from pages array
      pages.splice(currentPageIndex, 1);
      // Adjust currentPageIndex if necessary
      if (currentPageIndex >= pages.length) {
        currentPageIndex = pages.length - 1;
      }
      // Load the new current page
      let pageObj = pages[currentPageIndex];
      loadState(pageObj.data);
      undoStack = pageObj.undoStack.slice();
      redoStack = pageObj.redoStack.slice();
      updatePageNavButtons();
    }
    
    function initPage() {
      // Initialize with one blank page
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let pageObj = { data: canvas.toDataURL(), undoStack: [], redoStack: [] };
      pages.push(pageObj);
      currentPageIndex = 0;
      undoStack = [];
      redoStack = [];
      updatePageNavButtons();
      saveState();
    }
    
    // ---------- Mouse Event Handlers ------------
    canvas.addEventListener("mousedown", (e) => {
      // Adjust for nav bar height (70px)
      const mouseX = e.clientX;
      const mouseY = e.clientY - 70;
      
      if (tool === "fill") {
        saveState();
        floodFill(mouseX, mouseY, color);
        return;
      }
      
      isDrawing = true;
      startX = mouseX;
      startY = mouseY;
      
      if (tool === "draw" || tool === "eraser") {
        ctx.beginPath();
        ctx.moveTo(mouseX, mouseY);
      } else if (
        tool === "line" ||
        tool === "rect" ||
        tool === "circle" ||
        tool === "dotted" ||
        tool === "dashed"
      ) {
        savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }
    });
    
    canvas.addEventListener("mousemove", (e) => {
      if (!isDrawing) return;
      const mouseX = e.clientX;
      const mouseY = e.clientY - 70;
      
      if (tool === "draw" || tool === "eraser") {
        ctx.lineWidth = size;
        ctx.strokeStyle = tool === "eraser" ? "#fff" : color;
        ctx.lineCap = "round";
        ctx.lineTo(mouseX, mouseY);
        ctx.stroke();
      } else if (
        tool === "line" ||
        tool === "rect" ||
        tool === "circle" ||
        tool === "dotted" ||
        tool === "dashed"
      ) {
        ctx.putImageData(savedImageData, 0, 0);
        drawShape({ clientX: mouseX, clientY: mouseY + 70 }, true);
      }
    });
    
    canvas.addEventListener("mouseup", (e) => {
      if (!isDrawing) return;
      const mouseX = e.clientX;
      const mouseY = e.clientY - 70;
      
      if (tool === "draw" || tool === "eraser") {
        ctx.beginPath();
      } else if (
        tool === "line" ||
        tool === "rect" ||
        tool === "circle" ||
        tool === "dotted" ||
        tool === "dashed"
      ) {
        ctx.putImageData(savedImageData, 0, 0);
        drawShape({ clientX: mouseX, clientY: mouseY + 70 }, false);
      }
      isDrawing = false;
      saveState();
    });
    
    // ---------- Toolbar Button Event Listeners ------------
    document.getElementById("draw").addEventListener("click", () => { tool = "draw"; });
    document.getElementById("line").addEventListener("click", () => { tool = "line"; });
    document.getElementById("rect").addEventListener("click", () => { tool = "rect"; });
    document.getElementById("circle").addEventListener("click", () => { tool = "circle"; });
    document.getElementById("dotted").addEventListener("click", () => { tool = "dotted"; });
    document.getElementById("dashed").addEventListener("click", () => { tool = "dashed"; });
    document.getElementById("eraser").addEventListener("click", () => { tool = "eraser"; });
    document.getElementById("fill").addEventListener("click", () => { tool = "fill"; });
    document.getElementById("undo").addEventListener("click", undo);
    document.getElementById("redo").addEventListener("click", redo);
    document.getElementById("clear").addEventListener("click", () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      saveState();
    });
    
    // New page and delete page buttons
    document.getElementById("newPage").addEventListener("click", createNewPage);
    document.getElementById("deletePage").addEventListener("click", deleteCurrentPage);
    
    document.getElementById("colorPicker").addEventListener("change", (e) => { color = e.target.value; });
    document.getElementById("sizePicker").addEventListener("input", (e) => { size = parseInt(e.target.value, 10); });
    
    // ---------- Initialize the first page ------------
    initPage();
  </script>
</body>
</html>
